import crypto from 'node:crypto';
import fs from 'node:fs';
import path from 'node:path';
import { MethodSignature, ParameterDeclaration, Project, SyntaxKind, TypeLiteralNode, VariableDeclaration } from 'ts-morph';

import { Action, ActionContext, ActionResult } from './action.js';

const DOC_TAG_LYNX_MODULE = 'lynxmodule';

export class CodegenAction implements Action {
  description = 'Generate implementation code for objects with @lynxmodule annotation';
  name = 'codegen';

  async execute(context: ActionContext, _previousResult?: ActionResult): Promise<ActionResult> {
    context.logger.info(`Generating code for project at ${context.projectRoot}`)
    const {projectRoot} = context
    if (!projectRoot) {
      throw new Error('No input path provided from previous action');
    }

    context.logger.info('Find package.json and get package name');
    const packageJsonPath = path.join(projectRoot, 'package.json');
    if (!fs.existsSync(packageJsonPath)) {
      throw new Error(`package.json not found in ${projectRoot}`);
    }

    const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
    const packageName = packageJson.name;
    if (!packageName) {
      throw new Error('Package name not found in package.json');
    }

    context.logger.info(`Generate unique hash for the package name ${packageName}`);
    const packageHash = crypto.createHash('md5').update(packageName).digest('hex').slice(0, 8);

    context.logger.info('Find all .d.ts files in ' + projectRoot);
    const dtsFiles = this.findDtsFiles(projectRoot);
    if (dtsFiles.length === 0) {
      throw new Error('No .d.ts files found');
    }

    context.logger.info('Process files');
    const project = new Project();
    const generatedFiles: string[] = [];

    for (const dtsFile of dtsFiles) {
      context.logger.info(`Processing file ${dtsFile}`);
      const sourceFile = project.addSourceFileAtPath(dtsFile);
      const variableStatements = sourceFile.getVariableStatements();

      for (const variableStatement of variableStatements) {
        const jsDocs = variableStatement.getJsDocs();
        const hasLynxModuleAnnotation = jsDocs.some((jsDoc) => {
          const tags = jsDoc.getTags();
          return tags.some((tag) => tag.getTagName() === DOC_TAG_LYNX_MODULE);
        })
        if (!hasLynxModuleAnnotation) {
          continue;
        }

        const declarations = variableStatement.getDeclarations();
        for (const declaration of declarations) {
          const generatedCode = this.generateObjectImplementation(declaration, packageHash);
          const outputFileName = `${declaration.getName()}.ts`;
          const outputPath = this.writeGeneratedFile(projectRoot, outputFileName, generatedCode);
          generatedFiles.push(outputPath);
        }
      }
    }

    context.logger.info(`Generated ${generatedFiles.length} files:`);
    for (const file of generatedFiles) {
      context.logger.info(`  - ${file}`);
    }

    return {
      outputPaths: generatedFiles,
      result: undefined,
    };
  }

  private findDtsFiles(dir: string): string[] {
    const files: string[] = [];
    
    const traverse = (currentDir: string) => {
      const entries = fs.readdirSync(currentDir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(currentDir, entry.name);
        
        if (entry.isDirectory() && entry.name !== 'node_modules' && entry.name!== 'generated') {
          traverse(fullPath);
        } else if (entry.isFile() && entry.name.endsWith('.d.ts')) {
          files.push(fullPath);
        }
      }
    };
    
    traverse(dir);
    return files;
  }

  private generateObjectImplementation(variableDecl: VariableDeclaration, packageHash: string): string {
    const objectName = variableDecl.getName();
    if (!objectName) {
      throw new Error('Object name not found');
    }

    const nativeModuleName = `${objectName}_${packageHash}`;
    const typeNode = variableDecl.getTypeNode();
    
    let implementation = '// Generated by lepo codegen, do not modify manually\n';
    implementation += `export let ${objectName} = {\n`;
    
    if (typeNode && typeNode.getKind() === SyntaxKind.TypeLiteral) {
      const typeLiteral = typeNode as TypeLiteralNode;
      const members = typeLiteral.getMembers();
      
      for (const member of members) {
        if (member.getKind() === SyntaxKind.MethodSignature) {
          const methodSignature = member as MethodSignature;
          const methodName = methodSignature.getName();
          const parameters = methodSignature.getParameters();
          const returnType = methodSignature.getReturnTypeNode()?.getText() || 'void';
          
          const paramList = parameters.map((param: ParameterDeclaration) => {
            const name = param.getName();
            const type = param.getTypeNode()?.getText() || 'any';
            return `${name}: ${type}`;
          }).join(', ');
          
          const paramNames = parameters.map((param: ParameterDeclaration) => param.getName()).join(', ');
          
          implementation += `  ${methodName}(${paramList}): ${returnType} {\n`;
          implementation += `    return NativeModules.${nativeModuleName}.${methodName}(${paramNames});\n`;
          implementation += `  },\n`;
        }
      }
    }
    
    // Remove trailing comma if exists
    implementation = implementation.replace(/,\n$/, '\n');
    implementation += `};\n`;
    return implementation;
  }

  private writeGeneratedFile(projectRoot: string, fileName: string, content: string): string {
    const generatedDir = path.join(projectRoot, 'generated');
    
    if (!fs.existsSync(generatedDir)) {
      fs.mkdirSync(generatedDir, { recursive: true });
    }
    
    const filePath = path.join(generatedDir, fileName);
    fs.writeFileSync(filePath, content, 'utf8');
    
    return filePath;
  }
}